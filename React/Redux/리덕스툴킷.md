## 리덕스 툴킷

**Redux 툴킷은 리덕스 로직을 작성하기 위한 공식 권장 접근 방식**
리덕스 코어를 둘러싸고 있으며, 리덕스 앱을 빌드하는 데 필수적이라고 생각하는 패키지와
기능이 포함되어 있다. 리덕스 툴킷은 제안된 모범 사례를 기반으로 하여 대부분의 리덕스 작업을
단순화 하고 일반적인 실수를 방지하고 리덕스 애플리케이션을 더 쉽게 작성할 수 있게 한다.

<aside>
💡 리덕스 툴킷으로 만들어진 카운터 앱 살펴보기
https://redux-toolkit.js.org/tutorials/quick-start

</aside>

### 설치

**npx create-react-app my-app - - template redux-typescript**

https://github.com/reduxjs/redux-toolkit

---

### Store 생성하기

```tsx
import { configureStore } from '@reduxjs/toolkit';
export const store = configureStore({
    reducer: {},
});
```

### React에 Redux 스토어 제공

저장소가 생성되면 src/index.js에서 애플리케이션
주위에 React-Redux<Provider>를 배치하여
React 구성 요소에서 사용할 수 있도록 할 수 있다.
방금 만든 Redux 저장소를 가져오고
**주위에 <Provider>를 배치하고 저장소를 prop으로 전달**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/abd41589-d969-4129-8b90-fb32db68266b/593df279-7c10-4b63-ae62-c087ea107b9b/Untitled.png)

### Redux State Slice 생성

src/features/counter/counterSlice.js라는 새 파일을 추가
해당 파일에서 ReduxToolkit의 createSlice API를 가져온다

-   Redux 툴킷을 사용하면?
    리듀서에게 “mutaing”(변경) 로직을 작성할 수 있다. 그것은 immer 라이브러리를 사용하기
    때문에 실제로 상태를 변경하지 않는다.
    ”초안(draft)상태”에 대한 변경 사항을 감지하고 이러한 변경 사항을 기반으로 완전히
    새로운 불변(immutable)상태를 생성
    **= state를 직접적으로 변경하면 안되고, 하나 더 생성한 후 변경하여
    변경된걸 state에 넣어줘서 사용 / 원래있던 state를 변경하는건 아님 (불변성을지킴)**

### 스토어에 Slice Reducer 추가

다음으로 카운터 슬라이스에서 리듀서 함수를 가져와서 스토어에 추가
리듀서 매개변수 내부에 필드를 정의함으로써 스토어에 이 슬라이스 리듀서 함수를
사용하여 해당 상태에 대한 모든 업데이트를 처리하도록 지시

```tsx
export const store = configureStore({
    reducer: {
        counter: counterReducer,
    },
});
```

### React 컴포넌트에서 Redux state 및 Action 사용

-   useSelector : 저장소에서 데이터를 읽는다.
-   useDispatch : Action을 전달

```tsx
export function Counter(){
	const count = useSelector((state:RootState) => state.counter.value)
	const dispatch = useDispatch()
```

1. configureStore를 사용하여 Redux 저장소 만들기

-   configureStore는 reducer 함수를 명명된 인수로 받아들인다.
-   configureStore는 좋은 기본 설정으로 저장소를 자동으로 설정

2. React 애플리케이션 구성 요소에 Redux 저장소 제공

-   주위에 React-Redux<Provider> 구성 요소를 배치
-   Redux 저장소를 <Provider store = {store}> 로 전달

3. createSlice로 Redux “슬라이스” 리듀서 생성

-   문자열 이름, 초기 상태 및 명명된 리듀서 함수로 createSlice 호출
-   Reducer function은 Immer를 사용하여 상태를 “mutate”할 수 있다.
-   생성된 슬라이스 리듀서 및 액션 생성기 내보내기

4. React 구성 요소에서 React-Redux useSelector/useDispatch 후크 사용

-   useSelector Hooks를 사용하여 저장소에서 데이터 읽기
-   useDispatch Hooks를 사용하여 디스패치 함수를 가져오고 필요에 따라 작업을 디스패치

---

## API

### createSlice()

-   Redux Logic을 작성하기 위한 표준 접근 방식
-   createSlice 내부에서는 createAction과 createReducer를 사용
-   리듀서 함수의 대상인 초기상태와 “slice 이름”을 받아 리듀서와 상태에 해당하는
    액션 생성자와 액션 타입을 자동으로 생성하는 함수

### extraReducers

-   extraReducers를 사용하면 createSlice가 생성한 action type 외에 다른 action type에 응답
-   extraReducers로 지정된 케이스 리듀서는 “외부”액션을 참조하기 위한 것이므로,
    그들은 slice.actions에서 생성된 액션을 가지지 않을 것

```tsx
const counter = createSlice({
	name : 'counter'
	initialState : 0,
	reducers : {
		increment : (state) => state + 1,
		decrement : (state) => state - 1

extraReducers:(builder) =>{
	builder.addCase(incrementBy, (state,action) =>{
	return state + action.payload
})
builder.addCase(decrementBy, (state,action) =>{
	return state - action.payload
})
```

### createAsyncThunk

> crateAction의 비동기 버전
> createAction + Async ⇒ **createAsyncThunk**

<aside>
💡 **funtion createAsyncThunk(type, payloadCreator, options)**

</aside>

비동기 요청의 생명주기를 나타내는 추가 Redux action **type 상수**를 생성하는 데 사용되는 문자열 :

(예를 들어 ‘users/requestState’ type 인수는 다음 action type을 생성)

-   **pending : ‘users/requestState/pending’**
-   **fulfilled : ‘users/requestState/fulfilled’**
-   **rejected : ‘users/requestState/rejected’**

```tsx
function payloadCreator(arg, thunkAPI);
// thunkAPI : 일반적으로 Redux 썽크 함수에 전달되는 모든 매개변수와 추가 옵션을 포함하는 객체
```

-   dispatch : Redux 스토어 dispatch 메서드
-   getState : Redux 스토어 getState 메서드
-   extra : 설정 시 썽크 미들웨어에 제공되는 “추가 인수”(사용가능한경우)
-   requestld : 이 요청 시퀀스를 식별하기 위해 자동으로 생성된 고유 문자열 ID 값
-   signal : 앱 로직의 다른 부분이 이 요청을 취소가 필요한 것으로 표시했는지 확인하는 데 사용할 수
    있는 AbortController.signal rocp
-   rejectWithValue(value,[meta]) : rejectWithValue는 정의된 페이로드 및 메타와 함께 거부된
    응답을 반환하기 위해 작업 생성자에서 반환할 수 있는 유틸리티 함수. 그것은 당신이 어떤 값을
    주든 전달하고 거부된 작업의 페이로드에 반환. 메타도 전달하면 기존의 rejectAction.meta와 병합
-   fulfillWithValue(value,meta) : fulfilledAction.meta에 추가할 수 있는 기능을 가지고 있는 동안
    값으로 이행하기 위해 작업 생성자에서 반환할 수 있는 유틸리티 함수

```tsx
const updateUser = createAsyncThunk(
	'users/update',
	async (userData, {rejectWithValue }) => {
		const {id, ...fields } = userData
		try{
			const response = await userAPI.updateById(id, fields)
			return response.data.user
			} catch(err) {
				return rejectWithValue(err.response.data)
				//여기에 에러 값을 넣어 주면 action.payload의 값으로 됨
		}
```

**에러가 나면 action.payload값이 err.response.data가 됨**

```tsx
builder.addCase(fetchUserById.rejected, (state, action) => {
    state.error = action.payload;
});
```

### cancellation

1. thunk 실행 중 취소하기

-   toggle버튼을 눌러서 test 컴포넌트가 더 이상 사용되지 않는 unmount 될 때
    clean up 부분이 호출되므로 promise.abort()메소드가 호출되어서 thunk가 실행중에 중지,
    이렇게 되면 “thunkName/rejected” action이 dispatch 된다

```
const Test = () => {

    const dispatch = useAppDispatch();
    useEffect(() => {

        const promise = dispatch(incrementAsync(10))

        return () => {
            promise.abort();
        }
    }, [])


    return (
        <div>Test</div>
    )
```

1. abort 이벤트 발생 시 request도 취소하기

```
export const fetchUsersAsync = createAsyncThunk(
    'counter/fetchUsers',
    async (_, { signal }) => {
        const controller = new AbortController();
        signal.addEventListener('abort', () => controller.abort());

        await axios.get('https://jsonplaceholder.typicode.com/users', {
            signal: controller.signal,
        });
    }
);
```
